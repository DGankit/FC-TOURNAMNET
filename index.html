<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UEFA Champions League Style FIFA Tournament</title>
    <style>
        :root {
            --ucl-blue: #1a3e8c;
            --ucl-dark: #0a1f4d;
            --ucl-gold: #e6b220;
            --ucl-silver: #e0e0e0;
            --ucl-green: #4CAF50;
            --ucl-red: #f44336;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: url('https://images.unsplash.com/photo-1574629810360-7efbbe195018') center/cover fixed;
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 20px 0;
            background: rgba(0,0,0,0.7);
            border-bottom: 3px solid var(--ucl-gold);
            border-radius: 0 0 15px 15px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        header::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--ucl-blue), var(--ucl-gold), var(--ucl-blue));
        }

        h1, h2, h3 {
            color: var(--ucl-gold);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
        }

        .card {
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--ucl-gold);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--ucl-gold);
            flex-wrap: wrap;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: rgba(0,0,0,0.3);
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
            font-weight: bold;
        }

        .tab:hover {
            background: rgba(26, 62, 140, 0.5);
        }

        .tab.active {
            background: var(--ucl-blue);
            color: var(--ucl-gold);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .tab-content.active {
            display: block;
        }

        button {
            background-color: var(--ucl-gold);
            color: var(--ucl-dark);
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px 0;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background-color: #f8d05a;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        input, select, textarea {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            margin: 5px 0;
            width: 100%;
            background: rgba(255,255,255,0.9);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: rgba(0,0,0,0.5);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        th {
            background-color: var(--ucl-blue);
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: rgba(255,255,255,0.05);
        }

        tr:hover {
            background-color: rgba(255,255,255,0.1);
        }

        .player-input {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .groups-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .group {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--ucl-gold);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .group-standings {
            margin-bottom: 20px;
        }

        .group-matches {
            margin-top: 20px;
        }

        .match {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid var(--ucl-gold);
            position: relative;
        }

        .match::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 5px;
            height: 100%;
            background: var(--ucl-gold);
            border-radius: 5px 0 0 5px;
        }

        .match-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .match-score {
            font-weight: bold;
            margin: 0 10px;
            color: var(--ucl-gold);
        }

        .match-actions {
            display: flex;
            gap: 10px;
        }

        .score-input {
            width: 50px;
            text-align: center;
            padding: 5px;
        }

        .qualifying {
            background-color: rgba(26, 62, 140, 0.5);
            font-weight: bold;
        }

        .playoff {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .winner {
            color: var(--ucl-gold);
            font-weight: bold;
        }

        .winner::after {
            content: ' üèÜ';
        }

        .top-scorer {
            color: var(--ucl-gold);
            font-weight: bold;
        }

        .top-scorer::after {
            content: ' ‚öΩ';
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--ucl-blue);
            color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            animation: slideIn 0.5s;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .trophy {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 40px;
            animation: bounce 2s infinite;
            display: none;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .stats-card {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--ucl-gold);
        }

        @media (max-width: 768px) {
            .player-input {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                margin-bottom: 5px;
                border-radius: 5px;
            }
            
            .groups-container, .stats-container {
                display: grid;
            grid-template-columns: 1fr 1fr; /* Two columns side by side */
            gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öΩ UEFA Champions League Style FIFA Tournament</h1>
            <p>Create and manage your custom tournament with UCL rules</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="setup">Setup</div>
            <div class="tab" data-tab="groups">Group Stage</div>
            <div class="tab" data-tab="playoffs">Playoffs</div>
            <div class="tab" data-tab="knockout">Knockout Stage</div>
            <div class="tab" data-tab="stats">Statistics</div>
        </div>

        <div class="tab-content active" id="setupTab">
            <div class="card">
                <h2>1. Add Participants</h2>
                <div class="player-input">
                    <input type="text" id="playerName" placeholder="Player name" required>
                    <button id="addPlayer">Add Player</button>
                </div>
                
                <h3>Or Bulk Upload</h3>
                <input type="file" id="bulkUpload" accept=".csv">
                <button id="uploadBtn">Upload CSV</button>
                
                <h3>Current Players (<span id="playerCount">0</span>)</h3>
                <table id="playersTable">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="playersList"></tbody>
                </table>
            </div>

            <div class="card">
                <h2>2. Generate Tournament</h2>
                <p id="tournamentInfo">Add players to generate tournament</p>
                <button id="generateTournament">Generate Groups</button>
                <button id="resetTournament" style="background-color: var(--ucl-red); margin-left: 10px;">Reset Tournament</button>
            </div>
        </div>

        <div class="tab-content" id="groupsTab">
            <div class="card">
                <h2>Group Stage (Double Round-Robin)</h2>
                <div class="groups-container" id="groupsContainer"></div>
            </div>
        </div>

        <div class="tab-content" id="playoffsTab">
            <div class="card">
                <h2>Playoff Matches (2nd vs 3rd from different groups)</h2>
                <div id="playoffsContainer"></div>
            </div>
        </div>

        <div class="tab-content" id="knockoutTab">
            <div class="card">
                <h2>Knockout Stage</h2>
                <div class="bracket" id="bracket"></div>
            </div>
        </div>

        <div class="tab-content" id="statsTab">
            <div class="card">
                <h2>Tournament Statistics</h2>
                <div class="stats-container">
                    <div class="stats-card">
                        <h3>Top Scorers</h3>
                        <table id="topScorers">
                            <thead>
                                <tr>
                                    <th>Player</th>
                                    <th>Goals</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    
                    <div class="stats-card">
                        <h3>Tournament Standings</h3>
                        <table id="standings">
                            <thead>
                                <tr>
                                    <th>Pos</th>
                                    <th>Player</th>
                                    <th>Pld</th>
                                    <th>W</th>
                                    <th>D</th>
                                    <th>L</th>
                                    <th>GF</th>
                                    <th>GA</th>
                                    <th>GD</th>
                                    <th>Pts</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Trophy Animation -->
        <div class="trophy" id="trophy">üèÜ</div>

        <!-- Toast Notification -->
        <div class="toast" id="toast"></div>
    </div>

    <script>
        // Tournament Data Structure
        const tournament = {
            players: [],
            groups: [],
            matches: {
                groupStage: [],
                playoffs: [],
                knockout: []
            },
            stats: {},
            settings: {
                maxPlayers: 20,
                maxGroups: 4,
                advanceDirect: 1,  // Top 1 goes to quarter-finals
                advancePlayoff: 2   // Next 2 go to playoffs
            },
            currentStage: 'setup'
        };

        // DOM Elements
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const playerNameInput = document.getElementById('playerName');
        const addPlayerBtn = document.getElementById('addPlayer');
        const bulkUpload = document.getElementById('bulkUpload');
        const uploadBtn = document.getElementById('uploadBtn');
        const playersList = document.getElementById('playersList');
        const playerCount = document.getElementById('playerCount');
        const generateBtn = document.getElementById('generateTournament');
        const resetBtn = document.getElementById('resetTournament');
        const tournamentInfo = document.getElementById('tournamentInfo');
        const groupsContainer = document.getElementById('groupsContainer');
        const playoffsContainer = document.getElementById('playoffsContainer');
        const bracketContainer = document.getElementById('bracket');
        const standingsTable = document.querySelector('#standings tbody');
        const topScorersTable = document.querySelector('#topScorers tbody');
        const toast = document.getElementById('toast');
        const trophy = document.getElementById('trophy');

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadTournament();
            setupEventListeners();
            updateGenerateButton();
        });

        // Set up all event listeners
        function setupEventListeners() {
            // Tab Switching
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}Tab`).classList.add('active');
                    
                    localStorage.setItem('activeTab', tab.dataset.tab);
                });
            });

            // Add Player
            addPlayerBtn.addEventListener('click', addPlayer);

            // Bulk Upload
            uploadBtn.addEventListener('click', handleBulkUpload);

            // Generate Tournament
            generateBtn.addEventListener('click', generateTournament);

            // Reset Tournament
            resetBtn.addEventListener('click', resetTournament);

            // Enable/disable generate button based on player count
            playerNameInput.addEventListener('keyup', function(e) {
                if (e.key === 'Enter') {
                    addPlayer();
                }
            });
        }

        // Reset the entire tournament
        function resetTournament() {
            if (confirm('Are you sure you want to reset the entire tournament? All data will be lost!')) {
                tournament.players = [];
                tournament.groups = [];
                tournament.matches = {
                    groupStage: [],
                    playoffs: [],
                    knockout: []
                };
                tournament.currentStage = 'setup';
                
                localStorage.removeItem('fifaTournament');
                
                renderPlayerList();
                renderGroups();
                renderPlayoffs();
                renderBracket();
                renderStandings();
                updateGenerateButton();
                
                document.querySelector('.tab[data-tab="setup"]').click();
                showToast('Tournament has been reset');
            }
        }

        // Update generate button state and info text
        function updateGenerateButton() {
            const totalPlayers = tournament.players.length;
            const maxPlayers = tournament.settings.maxPlayers;
            
            generateBtn.disabled = totalPlayers > maxPlayers;
            
            if (totalPlayers <= maxPlayers) {
                const groupDistribution = calculateGroupDistribution(totalPlayers);
                const groupText = groupDistribution.groupSizes.map(size => `${size}`).join('/');
                tournamentInfo.textContent = `${totalPlayers} players will be divided into ${groupDistribution.numGroups} groups (${groupText})`;
                generateBtn.textContent = `Generate ${groupDistribution.numGroups} Groups`;
            } else {
                tournamentInfo.textContent = `Maximum ${maxPlayers} players allowed (remove ${totalPlayers - maxPlayers} players)`;
                generateBtn.textContent = 'Too Many Players';
            }
        }

        // Calculate optimal group distribution
        function calculateGroupDistribution(totalPlayers) {
            // Special case for 20 players - always create 4 groups of 5
            if (totalPlayers === 20) {
                return {
                    numGroups: 4,
                    groupSizes: [5, 5, 5, 5]
                };
            }
            
            // For other numbers, distribute as evenly as possible into up to 4 groups
            let numGroups = Math.min(Math.ceil(totalPlayers / 4), 4);
            let playersPerGroup = Math.floor(totalPlayers / numGroups);
            let remainder = totalPlayers % numGroups;
            
            // Create group sizes array
            const groupSizes = Array(numGroups).fill(playersPerGroup);
            for (let i = 0; i < remainder; i++) {
                groupSizes[i]++;
            }
            
            return {
                numGroups,
                groupSizes
            };
        }

        // Load tournament data from localStorage
        function loadTournament() {
            const savedData = localStorage.getItem('fifaTournament');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    
                    // First restore basic data
                    tournament.players = data.players || [];
                    tournament.settings = data.settings || tournament.settings;
                    tournament.currentStage = data.currentStage || 'setup';
                    
                    // Then restore groups with proper player references
                    tournament.groups = (data.groups || []).map(group => ({
                        ...group,
                        players: group.players.map(player => {
                            // Find the original player in our tournament.players array
                            const originalPlayer = tournament.players.find(p => p.id === player.id);
                            return originalPlayer ? {
                                ...originalPlayer,
                                // Override with group-specific stats
                                groupGoals: player.groupGoals || 0,
                                groupWins: player.groupWins || 0,
                                groupDraws: player.groupDraws || 0,
                                groupLosses: player.groupLosses || 0,
                                groupPoints: player.groupPoints || 0,
                                groupGD: player.groupGD || 0
                            } : player;
                        })
                    }));
                    
                    // Restore matches with proper player references
                    ['groupStage', 'playoffs', 'knockout'].forEach(stage => {
                        tournament.matches[stage] = (data.matches?.[stage] || []).map(match => ({
                            ...match,
                            player1: findPlayerInTournament(match.player1),
                            player2: findPlayerInTournament(match.player2),
                            winner: match.winner ? findPlayerInTournament(match.winner) : null
                        }));
                    });
                    
                    renderPlayerList();
                    updateGenerateButton();
                    
                    if (tournament.groups.length > 0) {
                        renderGroups();
                        renderPlayoffs();
                        renderBracket();
                        renderStandings();
                        renderTopScorers();
                    }
                    
                    showToast('Tournament data loaded successfully!');
                } catch (e) {
                    console.error('Error loading tournament data:', e);
                    showToast('Error loading saved data', 'error');
                }
            }

            // Load active tab
            const activeTab = localStorage.getItem('activeTab') || 'setup';
            document.querySelector(`.tab[data-tab="${activeTab}"]`).click();
        }

        // Helper function to find player in tournament data
        function findPlayerInTournament(playerData) {
            if (!playerData) return null;
            if (!playerData.id) return playerData; // Might be a simple object
            
            // First check in groups (where group-specific stats are)
            for (const group of tournament.groups) {
                const found = group.players.find(p => p.id === playerData.id);
                if (found) return found;
            }
            
            // Then check in main players array
            return tournament.players.find(p => p.id === playerData.id) || playerData;
        }

        // Save tournament data to localStorage
        function saveTournament() {
            try {
                // Before saving, we need to ensure we're not storing circular references
                const dataToSave = {
                    players: tournament.players,
                    groups: tournament.groups.map(group => ({
                        ...group,
                        players: group.players.map(player => ({
                            id: player.id,
                            name: player.name,
                            // Group-specific stats
                            groupGoals: player.groupGoals,
                            groupWins: player.groupWins,
                            groupDraws: player.groupDraws,
                            groupLosses: player.groupLosses,
                            groupPoints: player.groupPoints,
                            groupGD: player.groupGD
                        }))
                    })),
                    matches: {
                        groupStage: tournament.matches.groupStage.map(match => ({
                            ...match,
                            player1: { id: match.player1.id, name: match.player1.name },
                            player2: { id: match.player2.id, name: match.player2.name }
                        })),
                        playoffs: tournament.matches.playoffs.map(match => ({
                            ...match,
                            player1: { id: match.player1.id, name: match.player1.name },
                            player2: { id: match.player2.id, name: match.player2.name },
                            winner: match.winner ? { id: match.winner.id, name: match.winner.name } : null
                        })),
                        knockout: tournament.matches.knockout.map(match => ({
                            ...match,
                            player1: { id: match.player1.id, name: match.player1.name },
                            player2: { id: match.player2.id, name: match.player2.name }
                        }))
                    },
                    settings: tournament.settings,
                    currentStage: tournament.currentStage
                };
                
                localStorage.setItem('fifaTournament', JSON.stringify(dataToSave));
                updateGenerateButton();
            } catch (e) {
                console.error('Error saving tournament data:', e);
                showToast('Error saving tournament data', 'error');
            }
        }

        // Show toast notification
        function showToast(message, type = 'success') {
            toast.textContent = message;
            toast.style.backgroundColor = type === 'success' ? 'var(--ucl-blue)' : 
                                          type === 'error' ? 'var(--ucl-red)' : 'var(--ucl-gold)';
            toast.style.display = 'block';
            
            setTimeout(() => {
                toast.style.display = 'none';
            }, 3000);
        }

        // Show trophy animation
        function showTrophy() {
            trophy.style.display = 'block';
            setTimeout(() => {
                trophy.style.display = 'none';
            }, 3000);
        }

        // Add a new player
        function addPlayer() {
            const name = playerNameInput.value.trim();

            if (!name) {
                showToast('Please enter a player name!', 'error');
                return;
            }

            // Check for duplicate names
            if (tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                showToast('This player name is already registered!', 'error');
                return;
            }

            // Check if we've reached max players
            if (tournament.players.length >= tournament.settings.maxPlayers) {
                showToast(`Maximum ${tournament.settings.maxPlayers} players allowed!`, 'error');
                return;
            }

            // Add player
            const newPlayer = {
                id: Date.now().toString(),
                name,
                goals: 0,
                assists: 0,
                wins: 0,
                draws: 0,
                losses: 0,
                points: 0,
                goalDifference: 0,
                matchesPlayed: 0
            };

            tournament.players.push(newPlayer);
            renderPlayerList();
            saveTournament();

            // Clear input
            playerNameInput.value = '';
            playerNameInput.focus();

            showToast(`${name} added successfully!`);
        }

        // Handle bulk upload of players
        function handleBulkUpload() {
            const file = bulkUpload.files[0];
            if (!file) {
                showToast('Please select a file first!', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const lines = content.split('\n').filter(line => line.trim());
                    
                    let addedCount = 0;
                    let skippedCount = 0;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const name = lines[i].trim();
                        if (name && !name.toLowerCase().includes('name')) { // Skip header if exists
                            // Check for duplicates
                            if (!tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                                // Check if we've reached max players
                                if (tournament.players.length >= tournament.settings.maxPlayers) {
                                    skippedCount++;
                                    continue;
                                }
                                
                                tournament.players.push({
                                    id: Date.now().toString() + i,
                                    name,
                                    goals: 0,
                                    assists: 0,
                                    wins: 0,
                                    draws: 0,
                                    losses: 0,
                                    points: 0,
                                    goalDifference: 0,
                                    matchesPlayed: 0
                                });
                                addedCount++;
                            } else {
                                skippedCount++;
                            }
                        }
                    }
                    
                    renderPlayerList();
                    saveTournament();
                    
                    let message = `${addedCount} players added from file!`;
                    if (skippedCount > 0) {
                        message += ` ${skippedCount} skipped (duplicates or max players reached).`;
                    }
                    showToast(message);
                    
                } catch (e) {
                    console.error('Error processing file:', e);
                    showToast('Error processing the file. Please check the format (one name per line).', 'error');
                }
            };
            reader.readAsText(file);
        }

        // Render player list
        function renderPlayerList() {
            playersList.innerHTML = '';
            
            if (tournament.players.length === 0) {
                playersList.innerHTML = '<tr><td colspan="2">No players added yet</td></tr>';
                playerCount.textContent = '0';
                return;
            }

            tournament.players.forEach(player => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${player.name}</td>
                    <td><button class="delete-player" data-id="${player.id}">Delete</button></td>
                `;
                playersList.appendChild(row);
            });

            // Update count
            playerCount.textContent = tournament.players.length;
            updateGenerateButton();

            // Add delete handlers
            document.querySelectorAll('.delete-player').forEach(btn => {
                btn.addEventListener('click', function() {
                    const playerId = this.getAttribute('data-id');
                    const player = tournament.players.find(p => p.id === playerId);
                    
                    if (confirm(`Are you sure you want to remove ${player.name}?`)) {
                        tournament.players = tournament.players.filter(p => p.id !== playerId);
                        renderPlayerList();
                        saveTournament();
                        showToast(`${player.name} removed from tournament`);
                    }
                });
            });
        }

        // Generate tournament with dynamic group sizes
        function generateTournament() {
            const totalPlayers = tournament.players.length;
            const maxPlayers = tournament.settings.maxPlayers;
            
            if (totalPlayers > maxPlayers) {
                showToast(`Maximum ${maxPlayers} players allowed!`, 'error');
                return;
            }

            // Reset previous tournament data (but keep players)
            tournament.groups = [];
            tournament.matches = {
                groupStage: [],
                playoffs: [],
                knockout: []
            };
            tournament.currentStage = 'groups';

            // Calculate group distribution
            const groupDistribution = calculateGroupDistribution(totalPlayers);
            
            // Create groups with calculated distribution
            createGroups(groupDistribution);
            
            // Generate group stage matches
            generateGroupMatches();
            
            // Render everything
            renderGroups();
            renderStandings();
            renderTopScorers();
            
            // Save and switch to groups tab
            saveTournament();
            document.querySelector('.tab[data-tab="groups"]').click();
            
            showToast(`Tournament generated with ${groupDistribution.numGroups} groups!`);
            showTrophy();
        }

        // Create groups with dynamic sizes
        function createGroups(groupDistribution) {
            // Shuffle players randomly
            const shuffledPlayers = [...tournament.players].sort(() => 0.5 - Math.random());
            
            let playerIndex = 0;
            
            for (let i = 0; i < groupDistribution.numGroups; i++) {
                const groupSize = groupDistribution.groupSizes[i];
                const groupPlayers = shuffledPlayers.slice(playerIndex, playerIndex + groupSize);
                playerIndex += groupSize;
                
                tournament.groups.push({
                    id: `group-${i}`,
                    name: `Group ${String.fromCharCode(65 + i)}`,
                    players: groupPlayers.map(p => ({ 
                        ...p, 
                        groupGoals: 0,
                        groupWins: 0,
                        groupDraws: 0,
                        groupLosses: 0,
                        groupPoints: 0,
                        groupGD: 0 
                    }))
                });
            }
        }

        // Generate group stage matches (double round-robin)
        function generateGroupMatches() {
            tournament.groups.forEach(group => {
                const players = group.players;
                
                // Generate all possible unique pairings (home and away)
                for (let i = 0; i < players.length; i++) {
                    for (let j = i + 1; j < players.length; j++) {
                        // Home match
                        tournament.matches.groupStage.push({
                            id: `match-${group.id}-${players[i].id}-${players[j].id}-1`,
                            group: group.id,
                            player1: players[i],
                            player2: players[j],
                            score1: null,
                            score2: null,
                            completed: false,
                            leg: 'home',
                            date: null
                        });
                        
                        // Away match
                        tournament.matches.groupStage.push({
                            id: `match-${group.id}-${players[j].id}-${players[i].id}-2`,
                            group: group.id,
                            player1: players[j],
                            player2: players[i],
                            score1: null,
                            score2: null,
                            completed: false,
                            leg: 'away',
                            date: null
                        });
                    }
                }
            });
        }

        // Render groups with standings and fixtures
        function renderGroups() {
            groupsContainer.innerHTML = '';
            
            if (tournament.groups.length === 0) {
                groupsContainer.innerHTML = '<p>No groups generated yet. Please generate the tournament first.</p>';
                return;
            }

            // Create a container for each pair of groups
            for (let i = 0; i < tournament.groups.length; i += 2) {
                const groupPair = document.createElement('div');
                groupPair.className = 'group-pair';
                
                // First group in the pair
                if (tournament.groups[i]) {
                    groupPair.appendChild(createGroupElement(tournament.groups[i]));
                }
                
                // Second group in the pair
                if (tournament.groups[i + 1]) {
                    groupPair.appendChild(createGroupElement(tournament.groups[i + 1]));
                }
                
                groupsContainer.appendChild(groupPair);
            }
            
            // Add match update handlers
            document.querySelectorAll('.update-match').forEach(btn => {
                btn.addEventListener('click', updateGroupMatch);
            });
        }

        // Helper function to create a group element
        function createGroupElement(group) {
            const groupEl = document.createElement('div');
            groupEl.className = 'group';
            
            // Sort players by group standings
            group.players.sort((a, b) => {
                if (b.groupPoints !== a.groupPoints) return b.groupPoints - a.groupPoints;
                if (b.groupGD !== a.groupGD) return b.groupGD - a.groupGD;
                return b.groupGoals - a.groupGoals;
            });
            
            // Group standings
            let standingsHTML = `
                <h3>${group.name}</h3>
                <div class="group-standings">
                    <table>
                        <thead>
                            <tr>
                                <th>Pos</th>
                                <th>Player</th>
                                <th>Pts</th>
                                <th>Pld</th>
                                <th>W-D-L</th>
                                <th>GD</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            group.players.forEach((player, index) => {
                const matchesPlayed = player.groupWins + player.groupDraws + player.groupLosses;
                const qualifyingClass = index < tournament.settings.advanceDirect ? 'qualifying' : 
                                      index < tournament.settings.advanceDirect + tournament.settings.advancePlayoff ? 'playoff' : '';
                
                standingsHTML += `
                    <tr class="${qualifyingClass}">
                        <td>${index + 1}</td>
                        <td>${player.name}</td>
                        <td>${player.groupPoints}</td>
                        <td>${matchesPlayed}</td>
                        <td>${player.groupWins}-${player.groupDraws}-${player.groupLosses}</td>
                        <td>${player.groupGD}</td>
                    </tr>
                `;
            });
            
            standingsHTML += `</tbody></table></div>`;
            
            // Group matches
            const groupMatches = tournament.matches.groupStage.filter(m => m.group === group.id);
            let matchesHTML = '<div class="group-matches"><h4>Fixtures</h4>';
            
            groupMatches.forEach(match => {
                const status = match.completed ? 
                    `<span class="match-score">${match.score1}-${match.score2}</span>` : 
                    '<span class="match-score">vs</span>';
                
                matchesHTML += `
                    <div class="match">
                        <div class="match-info">
                            <span>${match.player1.name}</span>
                            ${status}
                            <span>${match.player2.name}</span>
                        </div>
                        ${!match.completed ? `
                        <div class="match-actions">
                            <input type="number" class="score-input" data-match-id="${match.id}" data-player="1" placeholder="Score" min="0">
                            <input type="number" class="score-input" data-match-id="${match.id}" data-player="2" placeholder="Score" min="0">
                            <button class="update-match" data-match-id="${match.id}">Update</button>
                        </div>
                        ` : ''}
                    </div>
                `;
            });
            
            matchesHTML += '</div>';
            groupEl.innerHTML = standingsHTML + matchesHTML;
            return groupEl;
        }
            
            // Add match update handlers
            document.querySelectorAll('.update-match').forEach(btn => {
                btn.addEventListener('click', updateGroupMatch);
            });
        

        // Update group match result
        function updateGroupMatch(e) {
            const matchId = e.target.getAttribute('data-match-id');
            const match = tournament.matches.groupStage.find(m => m.id === matchId);
            
            const score1 = parseInt(document.querySelector(`.score-input[data-match-id="${matchId}"][data-player="1"]`).value);
            const score2 = parseInt(document.querySelector(`.score-input[data-match-id="${matchId}"][data-player="2"]`).value);
            
            if (isNaN(score1)) {
                showToast('Please enter a valid score for Home Team', 'error');
                return;
            }
            
            if (isNaN(score2)) {
                showToast('Please enter a valid score for Away Team', 'error');
                return;
            }

            // Update match
            match.score1 = score1;
            match.score2 = score2;
            match.completed = true;
            match.date = new Date().toISOString();
            
            // Update player stats
            updateGroupPlayerStats(match, score1, score2);
            
            // Re-render groups and save
            renderGroups();
            renderStandings();
            renderTopScorers();
            saveTournament();
            showToast('Match result updated!');
            
            // Check if all group matches are done to generate playoffs
            const allGroupMatchesDone = tournament.matches.groupStage.every(m => m.completed);
            if (allGroupMatchesDone) {
                generatePlayoffs();
                renderPlayoffs();
                tournament.currentStage = 'playoffs';
                saveTournament();
                showToast('Group stage completed! Playoffs generated.', 'success');
            }
        }

        // Update player stats for group matches
        function updateGroupPlayerStats(match, score1, score2) {
            const group = tournament.groups.find(g => g.id === match.group);
            const player1 = group.players.find(p => p.id === match.player1.id);
            const player2 = group.players.find(p => p.id === match.player2.id);
            
            // Goals
            player1.groupGoals += score1;
            player2.groupGoals += score2;
            
            // Goal difference
            player1.groupGD += (score1 - score2);
            player2.groupGD += (score2 - score1);
            
            // Points and wins/draws/losses
            if (score1 > score2) {
                player1.groupWins++;
                player1.groupPoints += 3;
                player2.groupLosses++;
            } else if (score2 > score1) {
                player2.groupWins++;
                player2.groupPoints += 3;
                player1.groupLosses++;
            } else {
                player1.groupDraws++;
                player2.groupDraws++;
                player1.groupPoints += 1;
                player2.groupPoints += 1;
            }
            
            // Update overall stats
            updatePlayerStats(match.player1, match.player2, score1, score2);
        }

        // Update overall player stats
        function updatePlayerStats(player1, player2, score1, score2) {
            // Find the actual player objects in the tournament.players array
            const p1 = tournament.players.find(p => p.id === player1.id) || player1;
            const p2 = tournament.players.find(p => p.id === player2.id) || player2;
            
            // Goals
            p1.goals += score1;
            p2.goals += score2;
            
            // Goal difference
            p1.goalDifference += (score1 - score2);
            p2.goalDifference += (score2 - score1);
            
            // Matches played
            p1.matchesPlayed++;
            p2.matchesPlayed++;
            
            if (score1 > score2) {
                p1.wins++;
                p1.points += 3;
                p2.losses++;
            } else if (score2 > score1) {
                p2.wins++;
                p2.points += 3;
                p1.losses++;
            } else {
                p1.draws++;
                p2.draws++;
                p1.points += 1;
                p2.points += 1;
            }
        }

        // Generate playoff matches (2nd vs 3rd from different groups)
        function generatePlayoffs() {
            tournament.matches.playoffs = [];
            
            // Get all 2nd and 3rd place teams
            const secondPlaceTeams = [];
            const thirdPlaceTeams = [];
            
            tournament.groups.forEach(group => {
                // Sort group players by standings
                group.players.sort((a, b) => {
                    if (b.groupPoints !== a.groupPoints) return b.groupPoints - a.groupPoints;
                    if (b.groupGD !== a.groupGD) return b.groupGD - a.groupGD;
                    return b.groupGoals - a.groupGoals;
                });
                
                secondPlaceTeams.push(group.players[1]);
                thirdPlaceTeams.push(group.players[2]);
            });
            
            // Shuffle to create inter-group matchups
            secondPlaceTeams.sort(() => 0.5 - Math.random());
            thirdPlaceTeams.sort(() => 0.5 - Math.random());
            
            // Create playoff matches (2nd vs 3rd from different groups)
            for (let i = 0; i < secondPlaceTeams.length; i++) {
                tournament.matches.playoffs.push({
                    id: `playoff-${i}`,
                    player1: secondPlaceTeams[i],
                    player2: thirdPlaceTeams[(i + 1) % thirdPlaceTeams.length], // Ensure different groups
                    score1: null,
                    score2: null,
                    completed: false,
                    winner: null
                });
            }
        }

        // Render playoff matches
        function renderPlayoffs() {
            playoffsContainer.innerHTML = '';
            
            if (tournament.matches.playoffs.length === 0) {
                playoffsContainer.innerHTML = '<p>Playoff matches will be generated after group stage is completed</p>';
                return;
            }
            
            tournament.matches.playoffs.forEach(match => {
                const matchEl = document.createElement('div');
                matchEl.className = 'match';
                
                const status = match.completed ? 
                    `<span class="match-score">${match.score1}-${match.score2}</span>` : 
                    '<span class="match-score">vs</span>';
                
                matchEl.innerHTML = `
                    <div class="match-info">
                        <span>${match.player1.name} (2nd)</span>
                        ${status}
                        <span>${match.player2.name} (3rd)</span>
                    </div>
                    ${!match.completed ? `
                    <div class="match-actions">
                        <input type="number" class="score-input" data-match-id="${match.id}" data-player="1" placeholder="Score" min="0">
                        <input type="number" class="score-input" data-match-id="${match.id}" data-player="2" placeholder="Score" min="0">
                        <button class="update-playoff" data-match-id="${match.id}">Update</button>
                    </div>
                    ` : ''}
                `;
                
                playoffsContainer.appendChild(matchEl);
            });
            
            // Add playoff match update handlers
            document.querySelectorAll('.update-playoff').forEach(btn => {
                btn.addEventListener('click', updatePlayoffMatch);
            });
        }

        // Update playoff match result
        function updatePlayoffMatch(e) {
            const matchId = e.target.getAttribute('data-match-id');
            const match = tournament.matches.playoffs.find(m => m.id === matchId);
            
            const score1 = parseInt(document.querySelector(`.score-input[data-match-id="${matchId}"][data-player="1"]`).value);
            const score2 = parseInt(document.querySelector(`.score-input[data-match-id="${matchId}"][data-player="2"]`).value);
            
            if (isNaN(score1)) {
                showToast('Please enter a valid score for Home Team', 'error');
                return;
            }
            
            if (isNaN(score2)) {
                showToast('Please enter a valid score for Away Team', 'error');
                return;
            }

            // Update match
            match.score1 = score1;
            match.score2 = score2;
            match.completed = true;
            match.winner = score1 > score2 ? match.player1 : match.player2;
            match.date = new Date().toISOString();
            
            // Update player stats
            updatePlayerStats(match.player1, match.player2, score1, score2);
            
            // Re-render playoffs and save
            renderPlayoffs();
            renderStandings();
            renderTopScorers();
            saveTournament();
            showToast('Playoff match result updated!');
            
            // Check if all playoff matches are done to generate knockout stage
            const allPlayoffsDone = tournament.matches.playoffs.every(m => m.completed);
            if (allPlayoffsDone) {
                generateKnockoutStage();
                renderBracket();
                tournament.currentStage = 'knockout';
                saveTournament();
                showToast('Playoffs completed! Knockout stage generated.', 'success');
            }
        }

        // Generate knockout stage (quarter-finals)
        function generateKnockoutStage() {
            tournament.matches.knockout = [];
            
            // Get all group winners
            const groupWinners = tournament.groups.flatMap(group => 
                [group.players[0]]
            );
            
            // Get playoff winners
            const playoffWinners = tournament.matches.playoffs.map(match => match.winner);
            
            // Combine all quarter-finalists (group winners + playoff winners)
            const quarterFinalists = [...groupWinners, ...playoffWinners];
            
            // Shuffle and create quarter-final pairings
            quarterFinalists.sort(() => 0.5 - Math.random());
            
            for (let i = 0; i < quarterFinalists.length; i += 2) {
                const team1 = quarterFinalists[i];
                const team2 = quarterFinalists[i + 1];
                
                // First leg
                tournament.matches.knockout.push({
                    id: `qf-${i}-1`,
                    round: 'quarter-final',
                    player1: team1,
                    player2: team2,
                    score1: null,
                    score2: null,
                    completed: false,
                    leg: 'first',
                    date: null
                });
                
                // Second leg
                tournament.matches.knockout.push({
                    id: `qf-${i}-2`,
                    round: 'quarter-final',
                    player1: team2,
                    player2: team1,
                    score1: null,
                    score2: null,
                    completed: false,
                    leg: 'second',
                    date: null
                });
            }
        }

        // Render knockout bracket
        function renderBracket() {
            bracketContainer.innerHTML = '';
            
            if (tournament.matches.knockout.length === 0) {
                bracketContainer.innerHTML = '<p>Knockout stage will be generated after playoffs are completed</p>';
                return;
            }
            
            // Group matches by round
            const rounds = {
                'quarter-final': [],
                'semi-final': [],
                'final': []
            };
            
            tournament.matches.knockout.forEach(match => {
                if (rounds[match.round]) {
                    rounds[match.round].push(match);
                }
            });
            
            // Render each round
            for (const [roundName, matches] of Object.entries(rounds)) {
                if (matches.length === 0) continue;
                
                const roundEl = document.createElement('div');
                roundEl.className = 'round';
                roundEl.innerHTML = `<h3>${roundName.replace('-', ' ').toUpperCase()}</h3>`;
                
                matches.forEach(match => {
                    const status = match.completed ? 
                        `<span class="match-score">${match.score1}-${match.score2}</span>` : 
                        '<span class="match-score">vs</span>';
                    
                    const matchEl = document.createElement('div');
                    matchEl.className = 'match';
                    matchEl.innerHTML = `
                        <div class="match-info">
                            <span>${match.player1.name}</span>
                            ${status}
                            <span>${match.player2.name}</span>
                        </div>
                        <div class="match-meta">
                            ${match.leg === 'second' ? '(2nd leg)' : '(1st leg)'}
                        </div>
                        ${!match.completed ? `
                        <div class="match-actions">
                            <input type="number" class="score-input" data-match-id="${match.id}" data-player="1" placeholder="Score" min="0">
                            <input type="number" class="score-input" data-match-id="${match.id}" data-player="2" placeholder="Score" min="0">
                            <button class="update-knockout" data-match-id="${match.id}">Update</button>
                        </div>
                        ` : ''}
                    `;
                    
                    roundEl.appendChild(matchEl);
                });
                
                bracketContainer.appendChild(roundEl);
            }
            
            // Add knockout match update handlers
            document.querySelectorAll('.update-knockout').forEach(btn => {
                btn.addEventListener('click', updateKnockoutMatch);
            });
        }

        // Update knockout match result
        function updateKnockoutMatch(e) {
            const matchId = e.target.getAttribute('data-match-id');
            const match = tournament.matches.knockout.find(m => m.id === matchId);
            
            const score1 = parseInt(document.querySelector(`.score-input[data-match-id="${matchId}"][data-player="1"]`).value);
            const score2 = parseInt(document.querySelector(`.score-input[data-match-id="${matchId}"][data-player="2"]`).value);
            
            if (isNaN(score1)) {
                showToast('Please enter a valid score for Home Team', 'error');
                return;
            }
            
            if (isNaN(score2)) {
                showToast('Please enter a valid score for Away Team', 'error');
                return;
            }

            // Update match
            match.score1 = score1;
            match.score2 = score2;
            match.completed = true;
            match.date = new Date().toISOString();
            
            // Update player stats
            updatePlayerStats(match.player1, match.player2, score1, score2);
            
            // Re-render bracket and save
            renderBracket();
            renderStandings();
            renderTopScorers();
            saveTournament();
            showToast('Knockout match result updated!');
            
            // Check if we need to generate next round
            checkAndGenerateNextRound();
        }

        // Check if we need to generate next knockout round
        function checkAndGenerateNextRound() {
            // Check if all quarter-finals are complete to generate semi-finals
            if (tournament.matches.knockout.some(m => m.round === 'quarter-final' && !m.completed)) {
                return;
            }
            
            // Generate semi-finals if not already present
            if (!tournament.matches.knockout.some(m => m.round === 'semi-final')) {
                generateSemiFinals();
                renderBracket();
                saveTournament();
                showToast('Quarter-finals completed! Semi-finals generated.', 'success');
                return;
            }
            
            // Check if all semi-finals are complete to generate final
            if (tournament.matches.knockout.some(m => m.round === 'semi-final' && !m.completed)) {
                return;
            }
            
            // Generate final if not already present
            if (!tournament.matches.knockout.some(m => m.round === 'final')) {
                generateFinal();
                renderBracket();
                saveTournament();
                showToast('Semi-finals completed! Final generated.', 'success');
                return;
            }
            
            // Check if final is complete
            const finalMatch = tournament.matches.knockout.find(m => m.round === 'final');
            if (finalMatch && finalMatch.completed) {
                const winner = finalMatch.score1 > finalMatch.score2 ? finalMatch.player1 : finalMatch.player2;
                showToast(`Tournament completed! ${winner.name} is the champion!`, 'success');
                showTrophy();
            }
        }

        // Generate semi-finals
        function generateSemiFinals() {
            // Get quarter-final winners
            const quarterFinalWinners = [];
            
            // Group quarter-finals by pairing (each pair has 2 legs)
            for (let i = 0; i < tournament.matches.knockout.length; i += 2) {
                const leg1 = tournament.matches.knockout[i];
                const leg2 = tournament.matches.knockout[i + 1];
                
                if (leg1 && leg2 && leg1.completed && leg2.completed) {
                    const aggregate1 = leg1.score1 + leg2.score2;
                    const aggregate2 = leg1.score2 + leg2.score1;
                    
                    if (aggregate1 > aggregate2) {
                        quarterFinalWinners.push(leg1.player1);
                    } else if (aggregate2 > aggregate1) {
                        quarterFinalWinners.push(leg2.player1);
                    } else {
                        // Handle tie (use golden match if needed)
                        quarterFinalWinners.push(leg1.score1 > leg2.score1 ? leg1.player1 : leg2.player1);
                    }
                }
            }
            
            // Create semi-final pairings
            for (let i = 0; i < quarterFinalWinners.length; i += 2) {
                if (i + 1 >= quarterFinalWinners.length) break;
                
                const team1 = quarterFinalWinners[i];
                const team2 = quarterFinalWinners[i + 1];
                
                // First leg
                tournament.matches.knockout.push({
                    id: `sf-${i}-1`,
                    round: 'semi-final',
                    player1: team1,
                    player2: team2,
                    score1: null,
                    score2: null,
                    completed: false,
                    leg: 'first',
                    date: null
                });
                
                // Second leg
                tournament.matches.knockout.push({
                    id: `sf-${i}-2`,
                    round: 'semi-final',
                    player1: team2,
                    player2: team1,
                    score1: null,
                    score2: null,
                    completed: false,
                    leg: 'second',
                    date: null
                });
            }
        }

        // Generate final
        function generateFinal() {
            // Get semi-final winners
            const semiFinalWinners = [];
            
            // Group semi-finals by pairing
            const semiFinals = tournament.matches.knockout.filter(m => m.round === 'semi-final');
            for (let i = 0; i < semiFinals.length; i += 2) {
                const leg1 = semiFinals[i];
                const leg2 = semiFinals[i + 1];
                
                if (leg1 && leg2 && leg1.completed && leg2.completed) {
                    const aggregate1 = leg1.score1 + leg2.score2;
                    const aggregate2 = leg1.score2 + leg2.score1;
                    
                    if (aggregate1 > aggregate2) {
                        semiFinalWinners.push(leg1.player1);
                    } else if (aggregate2 > aggregate1) {
                        semiFinalWinners.push(leg2.player1);
                    } else {
                        // Handle tie (use golden match if needed)
                        semiFinalWinners.push(leg1.score1 > leg2.score1 ? leg1.player1 : leg2.player1);
                    }
                }
            }
            
            // Create final (single match)
            if (semiFinalWinners.length === 2) {
                tournament.matches.knockout.push({
                    id: `final-1`,
                    round: 'final',
                    player1: semiFinalWinners[0],
                    player2: semiFinalWinners[1],
                    score1: null,
                    score2: null,
                    completed: false,
                    leg: 'single',
                    date: null
                });
            }
        }

        // Render tournament standings
        function renderStandings() {
            standingsTable.innerHTML = '';
            
            // Sort players by tournament performance
            const sortedPlayers = [...tournament.players].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
                return b.goals - a.goals;
            });
            
            if (sortedPlayers.length === 0) {
                standingsTable.innerHTML = '<tr><td colspan="10">No data available yet</td></tr>';
                return;
            }
            
            sortedPlayers.forEach((player, index) => {
                const matchesPlayed = player.matchesPlayed;
                const row = document.createElement('tr');
                if (index === 0) row.classList.add('winner');
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${player.name}</td>
                    <td>${matchesPlayed}</td>
                    <td>${player.wins}</td>
                    <td>${player.draws}</td>
                    <td>${player.losses}</td>
                    <td>${player.goals}</td>
                    <td>${player.goals - player.goalDifference}</td>
                    <td>${player.goalDifference}</td>
                    <td><strong>${player.points}</strong></td>
                `;
                
                standingsTable.appendChild(row);
            });
        }

        // Render top scorers
        function renderTopScorers() {
            topScorersTable.innerHTML = '';
            
            // Sort players by goals
            const sortedPlayers = [...tournament.players].sort((a, b) => b.goals - a.goals);
            
            if (sortedPlayers.length === 0) {
                topScorersTable.innerHTML = '<tr><td colspan="2">No data available yet</td></tr>';
                return;
            }
            
            const maxGoals = sortedPlayers.length > 0 ? sortedPlayers[0].goals : 0;
            
            sortedPlayers.forEach((player, index) => {
                if (player.goals === 0) return; // Skip players with 0 goals
                
                const row = document.createElement('tr');
                if (player.goals === maxGoals && maxGoals > 0) {
                    row.classList.add('top-scorer');
                }
                
                row.innerHTML = `
                    <td>${player.name}</td>
                    <td>${player.goals}</td>
                `;
                
                topScorersTable.appendChild(row);
            });
            
            if (topScorersTable.innerHTML === '') {
                topScorersTable.innerHTML = '<tr><td colspan="2">No goals scored yet</td></tr>';
            }
        }
    </script>
</body>
</html>